# CG
<hr>
<h2>가비지컬렉션 (쓰레기 수집)</h2><br>

메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능

쓰레기 수집은 동적 할당된 메모리 영역 가운데 더 이상 사용할 수 없게 된 영역을 탐지하여 자동으로 해제하는 기법이다. 
더 이상 사용할 수 없게 된 영역이란, 어떤 변수도 가리키지 않게 된 영역을 의미한다

<h2>장단점</h2><br>

쓰레기 수집이 지원되는 환경에서는 프로그래머가 동적으로 할당한 메모리 영역의 전체를 완벽하게 관리할 필요가 없어진다. 쓰레기 수집은 다음과 같은 버그를 줄이거나 완전히 막을 수 있다.

유효하지 않은 포인터 접근: 이미 해제된 메모리에 접근하는 버그를 가리킨다. 만약 이 포인터가 해제되고 새로운 값이 할당되었다면, 잘못된 값을 읽어오게 된다.

이중 해제: 이미 해제된 메모리를 또다시 해제하는 버그를 가리킨다. 일부 메모리 할당 알고리즘에서는, 해제된 메모리를 다시 해제하려고 시도하는 것은 오류를 일으킬 수 있다.

메모리 누수: 더이상 필요하지 않은 메모리가 해제되지 않고 남아있는 버그를 가리킨다. 메모리 누수가 반복되면 메모리 고갈로 프로그램이 중단될 수 있다. 
(접근 가능한 메모리가 증가하여 메모리가 고갈되는 문제는 쓰레기 수집으로도 막을 수 없다)

반면, 쓰레기 수집 기법은 다음과 같은 단점을 갖고 있다.

어떤 메모리를 해제할지 결정하는 데 비용이 든다. 객체가 필요없어지는 시점을 프로그래머가 미리 알고 있는 경우에도 쓰레기 수집 알고리즘이 메모리 해제 시점을 추적해야 하므로, 
이 작업은 오버헤드가 된다.

쓰레기 수집이 일어나는 타이밍이나 점유 시간을 미리 예측하기 어렵다. 때문에 프로그램이 예측 불가능하게 일시적으로 정지할 수 있다. 이런 특성은 특히 실시간 시스템에는 적합하지 않다.

할당된 메모리가 해제되는 시점을 알 수 없다. 자원 할당과 변수 초기화를 일치하는 RAII(Resource Acquisition is Initialization) 스타일의 프로그래밍에서는, 
이것은 자원 해제 시점을 알 수 없다는 것을 의미한다.

<h2>가비지컬렉션 방식</h2><br>
<h3>포인터 추적 방식</h3>
대부분의 쓰레기 수집 기법은 포인터 추적 방식을 사용 한 개 이상의 변수가 접근 가능한 메모리는 앞으로 사용할 수 있는 메모리로 간주하고,
그밖에 메모리를 해제하는 방식

<h3>참조 횟수 계산 방식</h3><b>
일부 쓰레기 수집 기법은 참조 횟수 계산 방식을 이용한다. 각 객체에세 참조 횟수를 기억하여, 참조 횟수가 0이 되면 해당 객체를
해제하는 방식을 가리킨다. CPython에서 이 방식을 사용한다.
<h2>가비지컬렉션이 필요한 이유</h2><br>
  
개발자가 동적으로 할당된 메모리 전체를 관리할 필요가 없어져 유효하지 않은 포인터에 접근하거나 이미 한번 해제한
메모리를 두 번 해제하는 등 버그나 불필요한 작업을 해소가능하다.
  
<h2>가비지 컬렉션의 동작 방식</h2><br>
  주기적으로 JVM의 heap 메모리를 점검하여 스택에서 참조되지 않는 객체를 메모리에서 해제하는 장치
Garbage collector가 Stack의 모든 변수를 스켄하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹
Reachable Objec(리스트 안에 객체, 스택 → 힙(리스트) →힙(객체))가 참조하고 있는 객체도 찾아서 마킹 (1, 2 번을 Mark라 부름)
마킹되지 않은 객체를 Heap에서 제거 (Sweep이라 부름)
compact를 하는 GC라면, 단편화 된 메모리를 정리

  <h3>힙의 구조</h3>
영 제너레이션, 올드 제너레이션

영 제너레이션은 새롭게 생성된 객체가 할당되는 공간이다.
영 제너레이션은 에덴과 서바이버 공간으로 나뉜다.

객체가 힙메모리에 할당 되면 우선 에덴에 할당된다. 에덴 영역이 가득 찬다면, 마이너 GC(에덴 영역에서의 mark and sweep)가 일어난다. 여기서 reachable해서 살아남은 객체는, survivor영역으로 이동한다.

살아남아서 서바이버 영역으로 이동한 객체는 age가 증가한다.

또 다음 마이너 gc가 일어나면, 새로운 reachable 객체들은 서바이버 영역으로 이동하고, 기존 서바이버는 age가 1 증가한다.

이 과정이 반복되어 age가 일정 임계점을 돌파하면, old generation 영역으로 이동(promotion)한다.


  <h3>올드 제너레이션</h3>

영 제너레이션에서 특정 age가 넘은 참조 메모리들이 이동하는 공간이다.

이 공간이 가득차면, major GC(올드제너레이션에서의 mark and sweep)가 일어난다.

영과 올드로 나눈이유

GC 설계자들은 두가지 가설을 전제로 GC를 만들었다고 한다.

대부분의 객체는 금방 접근 불가능한 상태가 된다. 

오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.

그래서 영 제너레이션과 올드 제너레이션을 나누어놓고 힙 전체에서 GC를 진행하지 않고 
영 제너레이션 에서만 GC를 수행(minor GC)한다. 여기서 대부분의 garbage가 수거되기 때문에, 메모리 낭비를 막을 수 있다.


<h3>출처</h3>
https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)
https://spurdev.tistory.com/10
https://sihyung92.oopy.io/java/garbage-collect/1
https://mangkyu.tistory.com/120
https://junghyungil.tistory.com/133
