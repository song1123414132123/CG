# CG
<hr>
<h2>가비지컬렉션 (쓰레기 수집)</h2><br>

메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능

쓰레기 수집은 동적 할당된 메모리 영역 가운데 더 이상 사용할 수 없게 된 영역을 탐지하여 자동으로 해제하는 기법이다. 
더 이상 사용할 수 없게 된 영역이란, 어떤 변수도 가리키지 않게 된 영역을 의미한다

<h2>장단점</h2><br>

쓰레기 수집이 지원되는 환경에서는 프로그래머가 동적으로 할당한 메모리 영역의 전체를 완벽하게 관리할 필요가 없어진다. 쓰레기 수집은 다음과 같은 버그를 줄이거나 완전히 막을 수 있다.

유효하지 않은 포인터 접근: 이미 해제된 메모리에 접근하는 버그를 가리킨다. 만약 이 포인터가 해제되고 새로운 값이 할당되었다면, 잘못된 값을 읽어오게 된다.

이중 해제: 이미 해제된 메모리를 또다시 해제하는 버그를 가리킨다. 일부 메모리 할당 알고리즘에서는, 해제된 메모리를 다시 해제하려고 시도하는 것은 오류를 일으킬 수 있다.

메모리 누수: 더이상 필요하지 않은 메모리가 해제되지 않고 남아있는 버그를 가리킨다. 메모리 누수가 반복되면 메모리 고갈로 프로그램이 중단될 수 있다. 
(접근 가능한 메모리가 증가하여 메모리가 고갈되는 문제는 쓰레기 수집으로도 막을 수 없다)

반면, 쓰레기 수집 기법은 다음과 같은 단점을 갖고 있다.

어떤 메모리를 해제할지 결정하는 데 비용이 든다. 객체가 필요없어지는 시점을 프로그래머가 미리 알고 있는 경우에도 쓰레기 수집 알고리즘이 메모리 해제 시점을 추적해야 하므로, 
이 작업은 오버헤드가 된다.

쓰레기 수집이 일어나는 타이밍이나 점유 시간을 미리 예측하기 어렵다. 때문에 프로그램이 예측 불가능하게 일시적으로 정지할 수 있다. 이런 특성은 특히 실시간 시스템에는 적합하지 않다.

할당된 메모리가 해제되는 시점을 알 수 없다. 자원 할당과 변수 초기화를 일치하는 RAII(Resource Acquisition is Initialization) 스타일의 프로그래밍에서는, 
이것은 자원 해제 시점을 알 수 없다는 것을 의미한다.

<h2>가비지컬렉션 방식</h2>
<h3>포인터 추적 방식</h3>
대부분의 쓰레기 수집 기법은 포인터 추적 방식을 사용 한 개 이상의 변수가 접근 가능한 메모리는 앞으로 사용할 수 있는 메모리로 간주하고,
그밖에 메모리를 해제하는 방식

<h3>참조 횟수 계산 방식</h3><b>
일부 쓰레기 수집 기법은 참조 횟수 계산 방식을 이용한다. 각 객체에세 참조 횟수를 기억하여, 참조 횟수가 0이 되면 해당 객체를
해제하는 방식을 가리킨다. CPython에서 이 방식을 사용한다.
<h2>가비지컬렉션이 필요한 이유</h2>
  
개발자가 동적으로 할당된 메모리 전체를 관리할 필요가 없어져 유효하지 않은 포인터에 접근하거나 이미 한번 해제한
메모리를 두 번 해제하는 등 버그나 불필요한 작업을 해소가능하다.
  
<h2>가비지 컬렉션의 동작 방식</h2>
  주기적으로 JVM의 heap 메모리를 점검하여 스택에서 참조되지 않는 객체를 메모리에서 해제하는 장치
Garbage collector가 Stack의 모든 변수를 스켄하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹
Reachable Objec(리스트 안에 객체, 스택 → 힙(리스트) →힙(객체))가 참조하고 있는 객체도 찾아서 마킹 (1, 2 번을 Mark라 부름)
마킹되지 않은 객체를 Heap에서 제거 (Sweep이라 부름)
compact를 하는 GC라면, 단편화 된 메모리를 정리

  <h3>힙의 구조</h3>
영 제너레이션, 올드 제너레이션

영 제너레이션은 새롭게 생성된 객체가 할당되는 공간이다.
영 제너레이션은 에덴과 서바이버 공간으로 나뉜다.

객체가 힙메모리에 할당 되면 우선 에덴에 할당된다. 에덴 영역이 가득 찬다면, 마이너 GC(에덴 영역에서의 mark and sweep)가 일어난다. 여기서 reachable해서 살아남은 객체는, survivor영역으로 이동한다.

살아남아서 서바이버 영역으로 이동한 객체는 age가 증가한다.

또 다음 마이너 gc가 일어나면, 새로운 reachable 객체들은 서바이버 영역으로 이동하고, 기존 서바이버는 age가 1 증가한다.

이 과정이 반복되어 age가 일정 임계점을 돌파하면, old generation 영역으로 이동(promotion)한다.


  <h3>올드 제너레이션</h3>

영 제너레이션에서 특정 age가 넘은 참조 메모리들이 이동하는 공간이다.

이 공간이 가득차면, major GC(올드제너레이션에서의 mark and sweep)가 일어난다.

영과 올드로 나눈이유

GC 설계자들은 두가지 가설을 전제로 GC를 만들었다고 한다.

대부분의 객체는 금방 접근 불가능한 상태가 된다. 

오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.

그래서 영 제너레이션과 올드 제너레이션을 나누어놓고 힙 전체에서 GC를 진행하지 않고 
영 제너레이션 에서만 GC를 수행(minor GC)한다. 여기서 대부분의 garbage가 수거되기 때문에, 메모리 낭비를 막을 수 있다.

  <h2>Example(CG 효율을 높이는 코딩방법)</h2><Br>
 <p>[ 1. Collection의 크기를 예측하여 설정하라 ]</p>
모든 Java의 Collections와 그를 확장하여 구현한 구현체들(Trove나 Google의 Guava)은 내부적으로 배열을 사용한다. <br>
  배열의 크기는 불변의 값이라 초기에 할당 되면 수정이 불가능하다.<br>
  그렇기 때문에 처음에 설정한 크기를 초과하여 계속 item을 담으려고 하면 내부적으로 새로운 크기의 배열을 생성하고 item을 복사하게 된다.<br>
  그렇다면 기존의 배열은 어떻게 되는가? 더 이상 사용되지 않는 메모리 즉 가비지가 된다.<br>
물론 대부분의 Collection은 이러한 재할당(Re-Allocation) 과정을 최적화하려고 노력하고 있지만 가비지가 생기는 것은 불가피하다. <br>
  그렇기 때문에 가능하다면 Collection의 크기를 예측하여, 생성 시에 직접 설정해주도록 하자<br>
<code>
  // 크기를 예측하여 직접 설정하라 
  List<String> list = new ArrayList(5);
 </code>
  
<p>[ 2. Stream을 사용하라 ]</p>
파일로부터 데이터를 읽거나 네트워크를 통해 파일을 받는 경우, 다음과 같은 코드를 쉽게 접할 수 있다.
<code>
byte[] fileData = readFileToByteArray(new File("myfile.txt"));
  </code>
  
읽으려는 데이터의 크기가 작다면 상관이 없겠지만, 데이터의 크기가 크거나 예측할 수 없다면 그렇게 좋지 못한 방법이다. <br>
  왜냐하면 데이터의 크기가 너무 크다면 JVM이 해당 파일의 내용을 할당할 수 없어 OutOfMemoryErrors가 발생할 수 있으며, 할당이 되었다 하더라도 이후에 상당히 큰 규모의 가비지가 되기 때문이다. <br>
  이러한 문제를 예방하는 가장 좋은 방법은 InputStream을 직접 사용하는 것이다.<br>

InputStream은 내부적으로 Buffer를 두고 있어 일정한 크기(Chunk)만큼씩 데이터를 조회한다. <br>
  그렇기 때문에 InputStream을 사용하면 Buffer를 재사용함으로써 OutOfMemoryErrors를 방지할 수 있고, 가비지의 생성을 최소화할 수 있다. <br>
  실제로 대부분의 Major한 도구들은 Stream을 직접 받아 처리하도록 되어 있다.<br>
  <code>
  FileInputStream fis = new FileInputStream("myfile.txt");
MyProtoBufMessage msg = MyProtoBufMessage.parseFrom(fis);
  </code>
  
  <p> [ 3. String의 사용을 최적화하라 ]</p>
String은 거의 모든 자료구조에서 빼놓을 수 없는 부분이다. <br>
   그렇기에 String은 다른 값들보다 중요한 만큼 메모리에 더 큰 영향을 미친다. <br>
   그렇기 때문에 String을 다루는 것 역시 신경을 써야 한다.<br>

<p>1. 중복된 String이 생성되는 경우, JVM 옵션을 활용하라</p>
애플리케이션을 개발하다보면 동일한 String 문자열을 많이 생성하게 된다.<br>
  Java 8u20 업데이트부터는 동일한 문자열에 의해 불필요한 메모리를 사용을 줄이도록 새로운 JVM 파라미터(UseStringDeduplication)를 추가하였다. <br>
  해당 옵션을 사용하면 중복되는 String 인스턴스들을 Global Single Char[]로 관리하여 힙 메모리의 사용을 최적화할 수 있다.<br>
<code>
java -XX:+UseStringDeduplication -jar Application.java
  </code>
  
  <p> [ 4. 불변성(Immutability)을 활용하라 ]</p>
불변성(Immutability)을 활용하는 것은 많은 이점을 가져다주는데, 그 중에서 많은 사람들이 놓치는 것이 바로 GC의 성능을 높여준다는 것이다. <br>
  불변의 객체는 한번 생성된 이후에 수정이 불가능한 객체로, Java에서는 final 키워드를 사용하여 불변의 객체를 생성할 수 있다. <br>
  이렇게 객체를 생성하기 위해서는 객체를 가지는 컨테이너도 존재한다는 것인데, 당연히 불변의 객체가 먼저 생성되어야 컨테이너가 이 객체를 참조할 수 있을 것이다. <br>
  즉, 컨테이너는 컨테이너가 참조하는 가장 젊은 객체들보다 더 젊다는 것(늦게 생성되었다는 것)이다. <br>
  이러한 점은 GC가 수행될 때, 가비지 컬렉터가 컨테이너 하위의 불변 객체들은 Skip할 수 있도록 도와준다.<br>
  왜냐하면 해당 컨테이너가 살아있다는 것은 하위의 불변 객체들 역시 처음에 할당된 그 상태로 참조되고 있다는 것을 의미하기 때문이다.<br>
  <code>
    public class MutableHolder {
    private Object value;
    public Object getValue() { return value; }
    public void setValue(Object o) { value = o; }
}

public class ImmutableHolder {
    private final Object value;
    public ImmutableHolder(Object o) { value = o; }
    public Object getValue() { return value; }
}
  </code>
  
<h3>출처</h3>
https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)
https://spurdev.tistory.com/10
https://sihyung92.oopy.io/java/garbage-collect/1
https://mangkyu.tistory.com/120
https://junghyungil.tistory.com/133
